'\" t
.\" Automatically generated by Pandoc 2.17.0.1
.\"
.TH "for" 1 "" "" "" ""
.hy
.SH for
.PP
Runs a specified command for each file, within a set of files.
.SS Syntax
.IP
.nf
\f[C]
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
\f[R]
.fi
.SS Parameters
.PP
.TS
tab(@);
lw(31.5n) lw(38.5n).
T{
Parameter
T}@T{
Description
T}
_
T{
\f[C]{%% | %}<variable>\f[R]
T}@T{
Required.
Represents a replaceable parameter.
Use a single percent sign (\f[C]%\f[R]) to carry out the \f[B]for\f[R]
command at the command prompt.
Use double percent signs (\f[C]%%\f[R]) to carry out the \f[B]for\f[R]
command within a batch file.
Variables are case sensitive, and they must be represented with an
alphabetical value such as \f[B]%a\f[R], \f[B]%b\f[R], or \f[B]%c\f[R].
T}
T{
(\f[C]<set>\f[R])
T}@T{
Required.
Specifies one or more files, directories, or text strings, or a range of
values on which to run the command.
The parentheses are required.
T}
T{
\f[C]<command>\f[R]
T}@T{
Required.
Specifies the command that you want to carry out on each file,
directory, or text string, or on the range of values included in
\f[I]set\f[R].
T}
T{
\f[C]<commandlineoptions>\f[R]
T}@T{
Specifies any command-line options that you want to use with the
specified command.
T}
T{
/?
T}@T{
Displays help at the command prompt.
T}
.TE
.SS Remarks
.IP \[bu] 2
You can use this command within a batch file or directly from the
command prompt.
.IP \[bu] 2
The following attributes apply to the \f[B]for\f[R] command:
.RS 2
.IP \[bu] 2
This command replaces \f[C]% variable\f[R] or \f[C]%% variable\f[R] with
each text string in the specified set until the specified command
processes all of the files.
.IP \[bu] 2
Variable names are case sensitive, global, and no more than 52 can be
active at a time.
.IP \[bu] 2
To avoid confusion with the batch parameters, \f[C]%0\f[R] through
\f[C]%9\f[R], you can use any character for \f[I]variable\f[R] except
the numerals \f[B]0\f[R] through \f[B]9\f[R].
For simple batch files, a single character such as \f[C]%%f\f[R] will
work.
.IP \[bu] 2
You can use multiple values for \f[I]variable\f[R] in complex batch
files to distinguish different replaceable variables.
.RE
.IP \[bu] 2
The \f[I]set\f[R] parameter can represent a single group of files or
several groups of files.
You can use wildcard characters (\f[B]*\f[R] and \f[B]?\f[R]) to specify
a file set.
The following are valid file sets:
.RS 2
.IP
.nf
\f[C]
(*.doc)
(*.doc *.txt *.me)
(jan*.doc jan*.rpt feb*.doc feb*.rpt)
(ar??1991.* ap??1991.*)
\f[R]
.fi
.RE
.IP \[bu] 2
When you use this command, the first value in \f[I]set\f[R] replaces
\f[C]% variable\f[R] or \f[C]%% variable\f[R], and then the specified
command processes this value.
This continues until all of the files (or groups of files) that
correspond to the \f[I]set\f[R] value are processed.
.IP \[bu] 2
\f[B]In\f[R] and \f[B]do\f[R] aren\[cq]t parameters, but you must use
them with this command.
If you omit either of these keywords, an error message appears.
.IP \[bu] 2
If command extensions are enabled (that is the default), the following
additional forms of \f[B]for\f[R] are supported:
.RS 2
.IP \[bu] 2
\f[B]Directories only:\f[R] If \f[I]set\f[R] contains wildcard
characters (\f[B]*\f[R] or \f[B]?\f[R]), the specified \f[I]command\f[R]
executes for each directory (instead of a set of files in a specified
directory) that matches \f[I]set\f[R].
The syntax is:
.RS 2
.IP
.nf
\f[C]
for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[B]Recursive:\f[R] Walks the directory tree that is rooted at
\f[I]drive\f[R]:\f[I]path\f[R] and executes the \f[B]for\f[R] statement
in each directory of the tree.
If no directory is specified after \f[B]/r\f[R], the current directory
is used as the root directory.
If \f[I]set\f[R] is just a single period (.), it only enumerates the
directory tree.
The syntax is:
.RS 2
.IP
.nf
\f[C]
for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[B]Iterating a range of values:\f[R] Use an iterative variable to set
the starting value (\f[I]start\f[R]#) and then step through a set range
of values until the value exceeds the set ending value (\f[I]end\f[R]#).
\f[B]/l\f[R] will execute the iterative by comparing \f[I]start\f[R]#
with \f[I]end\f[R]#.
If \f[I]start\f[R]# is less than \f[I]end\f[R]# the command will
execute.
When the iterative variable exceeds \f[I]end\f[R]#, the command shell
exits the loop.
You can also use a negative \f[I]step\f[R]# to step through a range in
decreasing values.
For example, (1,1,5) generates the sequence 1 2 3 4 5 and (5,-1,1)
generates the sequence 5 4 3 2 1.
The syntax is:
.RS 2
.IP
.nf
\f[C]
for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[B]Iterating and file parsing:\f[R] Use file parsing to process
command output, strings, and file content.
Use iterative variables to define the content or strings that you want
to examine, and use the various \f[I]parsingkeywords\f[R] options to
further modify the parsing.
Use the \f[I]parsingkeywords\f[R] token option to specify which tokens
should be passed as iterative variables.
Note that when used without the token option, \f[B]/f\f[R] will only
examine the first token.
.RS 2
.PP
File parsing consists of reading the output, string, or file content,
and then breaking it into individual lines of text and parsing each line
into zero or more tokens.
The \f[B]for\f[R] loop is then called with the iterative variable value
set to the token.
By default, \f[B]/f\f[R] passes the first blank separated token from
each line of each file.
Blank lines are skipped.
.PP
The syntaxes are:
.IP
.nf
\f[C]
for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
for /f [<parsingkeywords>] {%%|%}<variable> in (\[aq]<command>\[aq]) do <command> [<commandlinepptions>]
\f[R]
.fi
.PP
The \f[I]set\f[R] argument specifies one or more file names.
Each file is opened, read, and processed before moving to the next file
in \f[I]set\f[R].
To override the default parsing behavior, specify
\f[I]parsingkeywords\f[R].
This is a quoted string that contains one or more keywords to specify
different parsing options.
.PP
If you use the \f[B]usebackq\f[R] option, use one of the following
syntaxes:
.IP
.nf
\f[C]
for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (\[aq]<LiteralString>\[aq]) do <command> [<commandlinepptions>]
for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (\[ga]<command>\[ga]) do <command> [<commandlinepptions>]
\f[R]
.fi
.PP
The following table lists the parsing keywords that you can use for
\f[I]parsingkeywords\f[R].
.PP
.TS
tab(@);
lw(27.2n) lw(42.8n).
T{
Keyword
T}@T{
Description
T}
_
T{
eol=\f[C]<c>\f[R]
T}@T{
Specifies an end of line character (just one character).
T}
T{
skip=\f[C]<n>\f[R]
T}@T{
Specifies the number of lines to skip at the beginning of the file.
T}
T{
delims=\f[C]<xxx>\f[R]
T}@T{
Specifies a delimiter set.
This replaces the default delimiter set of space and tab.
T}
T{
tokens=\f[C]<x,y,m\[en]n>\f[R]
T}@T{
Specifies which tokens from each line are to be passed to the
\f[B]for\f[R] loop for each iteration.
As a result, additional variable names are allocated.
\f[I]m-n\f[R] specifies a range, from the \f[I]m\f[R]th through the
\f[I]n\f[R]th tokens.
If the last character in the \f[B]tokens=\f[R] string is an asterisk
(\f[B]*\f[R]), an additional variable is allocated, and it receives the
remaining text on the line after the last token that is parsed.
T}
T{
usebackq
T}@T{
Specifies to run a back-quoted string as a command, use a single-quoted
string as a literal string, or, for long file names that contain spaces,
allow file names in \f[C]<set>\f[R], to each be enclosed in
double-quotation marks.
T}
.TE
.RE
.IP \[bu] 2
\f[B]Variable substitution:\f[R] The following table lists optional
syntax (for any variable \f[B]I\f[R]):
.RS 2
.PP
.TS
tab(@);
lw(46.7n) lw(23.3n).
T{
Variable with modifier
T}@T{
Description
T}
_
T{
\f[C]%\[ti]I\f[R]
T}@T{
Expands \f[C]%I\f[R] which removes any surrounding quotation marks.
T}
T{
\f[C]%\[ti]fI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a fully qualified path name.
T}
T{
\f[C]%\[ti]dI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a drive letter only.
T}
T{
\f[C]%\[ti]pI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a path only.
T}
T{
\f[C]%\[ti]nI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a file name only.
T}
T{
\f[C]%\[ti]xI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a file name extension only.
T}
T{
\f[C]%\[ti]sI\f[R]
T}@T{
Expands path to contain short names only.
T}
T{
\f[C]%\[ti]aI\f[R]
T}@T{
Expands \f[C]%I\f[R] to the file attributes of file.
T}
T{
\f[C]%\[ti]tI\f[R]
T}@T{
Expands \f[C]%I\f[R] to the date and time of file.
T}
T{
\f[C]%\[ti]zI\f[R]
T}@T{
Expands \f[C]%I\f[R] to the size of the file.
T}
T{
\f[C]%\[ti]$PATH:I\f[R]
T}@T{
Searches the directories listed in the PATH environment variable and
expands \f[C]%I\f[R] to the fully qualified name of the first directory
found.
If the environment variable name is not defined or the file is not found
by the search, this modifier expands to the empty string.
T}
.TE
.PP
The following table lists modifier combinations that you can use to get
compound results.
.PP
.TS
tab(@);
lw(52.1n) lw(17.9n).
T{
Variable with combined modifiers
T}@T{
Description
T}
_
T{
\f[C]%\[ti]dpI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a drive letter and path only.
T}
T{
\f[C]%\[ti]nxI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a file name and extension only.
T}
T{
\f[C]%\[ti]fsI\f[R]
T}@T{
Expands \f[C]%I\f[R] to a full path name with short names only.
T}
T{
\f[C]%\[ti]dp$PATH:I\f[R]
T}@T{
Searches the directories that are listed in the PATH environment
variable for \f[C]%I\f[R] and expands to the drive letter and path of
the first one found.
T}
T{
\f[C]%\[ti]ftzaI\f[R]
T}@T{
Expands \f[C]%I\f[R] to an output line that is like \f[B]dir\f[R].
T}
.TE
.PP
In the above examples, you can replace \f[C]%I\f[R] and PATH with other
valid values.
A valid \f[B]for\f[R] variable name ends the \f[B]%\[ti]\f[R] syntax.
.PP
By using uppercase variable names such as \f[C]%I\f[R], you can make
your code more readable and avoid confusion with the modifiers, which
are not case sensitive.
.RE
.RE
.IP \[bu] 2
\f[B]Parsing a string:\f[R] You can use the \f[C]for /f\f[R] parsing
logic on an immediate string by wrapping \f[C]<literalstring>\f[R] in
either: double quotes (\f[I]without\f[R] usebackq) or in single quotes
(\f[I]with\f[R] usebackq) \[en]for example, (MyString) or (`MyString').
\f[C]<literalstring>\f[R] is treated as a single line of input from a
file.
When parsing \f[C]<literalstring>\f[R] in double-quotes, command symbols
(such as, \f[C]\[rs] & | > < \[ha]\f[R]) are treated as ordinary
characters.
.IP \[bu] 2
\f[B]Parsing output:\f[R] You can use the \f[C]for /f\f[R] command to
parse the output of a command by placing a back-quoted
\f[C]<command>\f[R] between the parentheses.
It is treated as a command line, which is passed to a child Cmd.exe.
The output is captured into memory and parsed as if it is a file.
.SS Examples
.PP
To use \f[B]for\f[R] in a batch file, use the following syntax:
.IP
.nf
\f[C]
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
\f[R]
.fi
.PP
To display the contents of all the files in the current directory that
have the extension .doc or .txt by using the replaceable variable
\f[B]%f\f[R], type:
.IP
.nf
\f[C]
for %f in (*.doc *.txt) do type %f
\f[R]
.fi
.PP
In the preceding example, each file that has the .doc or .txt extension
in the current directory is substituted for the \f[B]%f\f[R] variable
until the contents of every file are displayed.
To use this command in a batch file, replace every occurrence of
\f[B]%f\f[R] with \f[B]%%f\f[R].
Otherwise, the variable is ignored and an error message is displayed.
.PP
To parse a file, ignoring commented lines, type:
.IP
.nf
\f[C]
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do \[at]echo %i %j %k
\f[R]
.fi
.PP
This command parses each line in \f[I]myfile.txt\f[R].
It ignores lines that begin with a semicolon and passes the second and
third token from each line to the \f[B]for\f[R] body (tokens are
delimited by commas or spaces).
The body of the \f[B]for\f[R] statement references \f[B]%i\f[R] to get
the second token, \f[B]%j\f[R] to get the third token, and \f[B]%k\f[R]
to get all of the remaining tokens.
If the file names that you supply contain spaces, use quotation marks
around the text (for example, File Name).
To use quotation marks, you must use \f[B]usebackq\f[R].
Otherwise, the quotation marks are interpreted as defining a literal
string to parse.
.PP
\f[B]%i\f[R] is explicitly declared in the \f[B]for\f[R] statement.
\f[B]%j\f[R] and \f[B]%k\f[R] are implicitly declared by using
\f[B]tokens=\f[R].
You can use \f[B]tokens=\f[R] to specify up to 26 tokens, provided that
it does not cause an attempt to declare a variable higher than the
letter z or Z.
.PP
To parse the output of a command by placing \f[I]set\f[R] between the
parentheses, type:
.IP
.nf
\f[C]
for /f usebackq delims== %i in (\[aq]set\[aq]) do \[at]echo %i
\f[R]
.fi
.SS Additional References
.IP \[bu] 2
Command-Line Syntax Key
.SH AUTHORS
JasonGerend.
